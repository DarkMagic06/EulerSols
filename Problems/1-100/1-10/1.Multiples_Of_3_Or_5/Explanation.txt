## Problem Statement

*If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3,5,6 and 9. The sum of these multiples is 23.

Find the sum of all the multiples of 3 or 5 below 1000.*


## Personal Notes
This was my second introduction to the site, also a long time since using C as a programming tool.
I wanted to use Python and Rust but I don't yet have the necessary knowledge even though the problem is mostly trivial.

## Thought Process
We need the multiples of 3 and 5 below a certain upper bound (in this case 1000). There could be a case where we could use 2 separate for loops counting all the multiples of 3 and 5 separately.
The thing is, the time complexity could shoot up high, maybe a hardware parallel implementation with 2 modules ,one for counting the 3 multiples and one for the 5 multiples, could significantly lower the time and power costs
For the C implementation, the brute force approach seems most reasonable because there seems to be a case for the 15 multiples being counted twice. All that said, further optimizations could prove more efficient on time and hardware constraints

## Initial Approach
Brute force, works well because upper limit is only 1000

## Implementation Notes
- Language: C
- Key insight: modulo operation with OR condition
- Edge case: multiples of 15 counted once

## Optimizations Considered
[future: arithmetic series approach]

## Future Work
- [ ] Python implementation
- [ ] Rust implementation  
- [ ] Mathematical O(1) solution (implemented on 30/11/2025)

## Mathematical implementation
While the previous implementation was the first term intuition, it was not optimal.
The time complexity was O(n) because it had to iterate every number up to n which was the upper bound minus 1

using the Arithmetic series sum formula n*(n+1)/2 multiplying the sum by the multiplier (3,5 and 15) and dividing the upper_bound by the multiplier in each case.
Time complexity went from O(n) to O(1) because there was only one line of code in terms of mathematical operations to be done.
Even though for such small scale it may not matter, for larger implementations it could reduce costs and operational time significantly

